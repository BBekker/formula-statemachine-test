/** Generated by YAKINDU Statechart Tools code generator. */

#ifndef AMS_H_
#define AMS_H_

#ifdef __cplusplus
extern "C" { 
#endif

/*!
* Forward declaration for the Ams state machine.
*/
typedef struct Ams Ams;

/*!
* Forward declaration of the data structure for the AmsIface interface scope.
*/
typedef struct AmsIface AmsIface;

/*!
* Forward declaration of the data structure for the AmsTimeEvents interface scope.
*/
typedef struct AmsTimeEvents AmsTimeEvents;

/*!
* Forward declaration of the data structure for the AmsShadow interface scope.
*/
typedef struct AmsShadow AmsShadow;

#ifdef __cplusplus
}
#endif

#include "..\src\sc_types.h"
#include "air.h"

#ifdef __cplusplus
extern "C" { 
#endif 

/*! \file Header of the state machine 'ams'.
*/

/*! Define number of states in the state enum */
#define AMS_STATE_COUNT 14

/*! Define dimension of the state configuration vector for orthogonal states. */
#define AMS_MAX_ORTHOGONAL_STATES 1
/*! Define maximum number of time events that can be active at once */
#define AMS_MAX_PARALLEL_TIME_EVENTS 1

/*! Define indices of states in the StateConfVector */
#define SCVI_AMS_MAIN_REGION_STANDBY 0
#define SCVI_AMS_MAIN_REGION_ARMED 0
#define SCVI_AMS_MAIN_REGION_HV_ACTIVE 0
#define SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_PRECHARGING 0
#define SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_PRECHARGING_PRECHARGE_SEQUENCE_CLOSE_L 0
#define SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_PRECHARGING_PRECHARGE_SEQUENCE_CLOSE_PRECHARGE 0
#define SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_PRECHARGING_PRECHARGE_SEQUENCE_CLOSE_H 0
#define SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_PRECHARGING_PRECHARGE_SEQUENCE_WAIT_VOLTAGE 0
#define SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_READY_TO_DRIVE 0
#define SCVI_AMS_MAIN_REGION_DISCHARGING 0
#define SCVI_AMS_MAIN_REGION_DISCHARGING_DISCHARGE_SEQUENCE_WAIT_FOR_CURRENT 0
#define SCVI_AMS_MAIN_REGION_DISCHARGING_DISCHARGE_SEQUENCE_DISCHARGE 0
#define SCVI_AMS_MAIN_REGION_ERROR_DISCHARGING 0
#define SCVI_AMS_MAIN_REGION_SETUP 0

/*! Enumeration of all states */ 
typedef enum
{
	Ams_last_state,
	Ams_main_region_Standby,
	Ams_main_region_Armed,
	Ams_main_region_HV_Active,
	Ams_main_region_HV_Active_active_states_Precharging,
	Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L,
	Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge,
	Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H,
	Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage,
	Ams_main_region_HV_Active_active_states_ready_to_drive,
	Ams_main_region_Discharging,
	Ams_main_region_Discharging_Discharge_sequence_Wait_for_current,
	Ams_main_region_Discharging_Discharge_sequence_Discharge,
	Ams_main_region_error_discharging,
	Ams_main_region_Setup
} AmsStates;




/*! Type declaration of the data structure for the AmsIface interface scope. */
struct AmsIface
{
	Air* air_h;
	Air* air_l;
	Air* precharge;
	sc_boolean Discharge_raised;
	sc_boolean Charge_raised;
	sc_boolean TSMS;
	float V_MC;
	float I_bat;
};





/*! Type declaration of the data structure for the AmsTimeEvents interface scope. */
struct AmsTimeEvents
{
	sc_boolean ams_main_region_Discharging_Discharge_sequence_Wait_for_current_tev0_raised;
};



/*! Type declaration of the data structure for the AmsShadow interface scope. */
struct AmsShadow
{
	sc_boolean air_l_failed_open_raised;
	sc_boolean air_h_failed_open_raised;
	sc_boolean precharge_failed_open_raised;
	sc_boolean air_l_closed_raised;
	sc_boolean precharge_closed_raised;
	sc_boolean air_h_closed_raised;
	sc_single_subscription_observer air_l_failed_open;
	sc_single_subscription_observer air_h_failed_open;
	sc_single_subscription_observer precharge_failed_open;
	sc_single_subscription_observer air_l_closed;
	sc_single_subscription_observer precharge_closed;
	sc_single_subscription_observer air_h_closed;
};





typedef struct AmsIfaceEvBuf AmsIfaceEvBuf;
struct AmsIfaceEvBuf {
	sc_boolean Discharge_raised;
	sc_boolean Charge_raised;
};

typedef struct AmsTimeEventsEvBuf AmsTimeEventsEvBuf;
struct AmsTimeEventsEvBuf {
	sc_boolean ams_main_region_Discharging_Discharge_sequence_Wait_for_current_time_event_0_raised;
};

typedef struct AmsShadowEvBuf AmsShadowEvBuf;
struct AmsShadowEvBuf {
	sc_boolean air_l_failed_open_raised;
	sc_boolean air_h_failed_open_raised;
	sc_boolean precharge_failed_open_raised;
	sc_boolean air_l_closed_raised;
	sc_boolean precharge_closed_raised;
	sc_boolean air_h_closed_raised;
};

typedef struct AmsEvBuf AmsEvBuf;
struct AmsEvBuf {
	AmsIfaceEvBuf iface;
	AmsTimeEventsEvBuf timeEvents;
	AmsShadowEvBuf shadow;
};


/*! 
 * Type declaration of the data structure for the Ams state machine.
 * This data structure has to be allocated by the client code. 
 */
struct Ams
{
	AmsStates stateConfVector[AMS_MAX_ORTHOGONAL_STATES];
	AmsIface iface;
	AmsTimeEvents timeEvents;
	AmsShadow shadow;
	AmsEvBuf current;
	sc_boolean isExecuting;
};



/*! Initializes the Ams state machine data structures. Must be called before first usage.*/
extern void ams_init(Ams* handle);


/*! Performs a 'run to completion' step. */
extern void ams_run_cycle(Ams* handle);

/*! Activates the state machine. */
extern void ams_enter(Ams* handle);

/*! Deactivates the state machine. */
extern void ams_exit(Ams* handle);



/*! Raises a time event. */
extern void ams_raise_time_event(Ams* handle, sc_eventid evid);

/*! Gets the value of the variable 'air_h' that is defined in the default interface scope. */ 
extern Air* ams_get_air_h(const Ams* handle);
/*! Sets the value of the variable 'air_h' that is defined in the default interface scope. */ 
extern void ams_set_air_h(Ams* handle, Air* value);
/*! Gets the value of the variable 'air_l' that is defined in the default interface scope. */ 
extern Air* ams_get_air_l(const Ams* handle);
/*! Sets the value of the variable 'air_l' that is defined in the default interface scope. */ 
extern void ams_set_air_l(Ams* handle, Air* value);
/*! Gets the value of the variable 'precharge' that is defined in the default interface scope. */ 
extern Air* ams_get_precharge(const Ams* handle);
/*! Sets the value of the variable 'precharge' that is defined in the default interface scope. */ 
extern void ams_set_precharge(Ams* handle, Air* value);
/*! Raises the in event 'Discharge' that is defined in the default interface scope. */ 
extern void ams_raise_discharge(Ams* handle);
/*! Raises the in event 'Charge' that is defined in the default interface scope. */ 
extern void ams_raise_charge(Ams* handle);
/*! Gets the value of the variable 'TSMS' that is defined in the default interface scope. */ 
extern sc_boolean ams_get_tSMS(const Ams* handle);
/*! Sets the value of the variable 'TSMS' that is defined in the default interface scope. */ 
extern void ams_set_tSMS(Ams* handle, sc_boolean value);
/*! Gets the value of the variable 'V_MC' that is defined in the default interface scope. */ 
extern float ams_get_v_MC(const Ams* handle);
/*! Sets the value of the variable 'V_MC' that is defined in the default interface scope. */ 
extern void ams_set_v_MC(Ams* handle, float value);
/*! Gets the value of the variable 'I_bat' that is defined in the default interface scope. */ 
extern float ams_get_i_bat(const Ams* handle);
/*! Sets the value of the variable 'I_bat' that is defined in the default interface scope. */ 
extern void ams_set_i_bat(Ams* handle, float value);

/*!
 * Checks whether the state machine is active (until 2.4.1 this method was used for states).
 * A state machine is active if it was entered. It is inactive if it has not been entered at all or if it has been exited.
 */
extern sc_boolean ams_is_active(const Ams* handle);

/*!
 * Checks if all active states are final. 
 * If there are no active states then the state machine is considered being inactive. In this case this method returns false.
 */
extern sc_boolean ams_is_final(const Ams* handle);

/*! Checks if the specified state is active (until 2.4.1 the used method for states was called isActive()). */
extern sc_boolean ams_is_state_active(const Ams* handle, AmsStates state);


#ifdef __cplusplus
}
#endif 

#endif /* AMS_H_ */
