/** Generated by YAKINDU Statechart Tools code generator. */


#include "..\src\sc_types.h"

#include "air.h"
#include "air_required.h"

/*! \file Implementation of the state machine 'air'
*/

#ifndef SC_UNUSED
#define SC_UNUSED(P) (void)(P)
#endif

/* prototypes of all internal functions */
static void enact_main_region_Open(Air* handle);
static void enact_main_region_DoClose(Air* handle);
static void enact_main_region_DoOpen(Air* handle);
static void enact_main_region_Welded(Air* handle);
static void enact_main_region_Closed(Air* handle);
static void enact_main_region_Closed_PWMController_PullIn(Air* handle);
static void enact_main_region_Closed_PWMController_PowerSave(Air* handle);
static void enact_main_region_CloseFailed(Air* handle);
static void exact_main_region_DoClose(Air* handle);
static void exact_main_region_DoOpen(Air* handle);
static void exact_main_region_Closed_PWMController_PullIn(Air* handle);
static void enseq_main_region_Open_default(Air* handle);
static void enseq_main_region_DoClose_default(Air* handle);
static void enseq_main_region_DoOpen_default(Air* handle);
static void enseq_main_region_Welded_default(Air* handle);
static void enseq_main_region_Closed_default(Air* handle);
static void enseq_main_region_Closed_PWMController_PullIn_default(Air* handle);
static void enseq_main_region_Closed_PWMController_PowerSave_default(Air* handle);
static void enseq_main_region_CloseFailed_default(Air* handle);
static void enseq_main_region_default(Air* handle);
static void enseq_main_region_Closed_PWMController_default(Air* handle);
static void exseq_main_region_Open(Air* handle);
static void exseq_main_region_DoClose(Air* handle);
static void exseq_main_region_DoOpen(Air* handle);
static void exseq_main_region_Welded(Air* handle);
static void exseq_main_region_Closed(Air* handle);
static void exseq_main_region_Closed_PWMController_PullIn(Air* handle);
static void exseq_main_region_Closed_PWMController_PowerSave(Air* handle);
static void exseq_main_region_CloseFailed(Air* handle);
static void exseq_main_region(Air* handle);
static void exseq_main_region_Closed_PWMController(Air* handle);
static void react_main_region__entry_Default(Air* handle);
static void react_main_region_Closed_PWMController__entry_Default(Air* handle);

/*! State machine reactions. */
static sc_integer react(Air* handle, const sc_integer transitioned_before);

/*! The reactions of state Open. */
static sc_integer main_region_Open_react(Air* handle, const sc_integer transitioned_before);

/*! The reactions of state DoClose. */
static sc_integer main_region_DoClose_react(Air* handle, const sc_integer transitioned_before);

/*! The reactions of state DoOpen. */
static sc_integer main_region_DoOpen_react(Air* handle, const sc_integer transitioned_before);

/*! The reactions of state Welded. */
static sc_integer main_region_Welded_react(Air* handle, const sc_integer transitioned_before);

/*! The reactions of state Closed. */
static sc_integer main_region_Closed_react(Air* handle, const sc_integer transitioned_before);

/*! The reactions of state PullIn. */
static sc_integer main_region_Closed_PWMController_PullIn_react(Air* handle, const sc_integer transitioned_before);

/*! The reactions of state PowerSave. */
static sc_integer main_region_Closed_PWMController_PowerSave_react(Air* handle, const sc_integer transitioned_before);

/*! The reactions of state CloseFailed. */
static sc_integer main_region_CloseFailed_react(Air* handle, const sc_integer transitioned_before);


static void swap_in_events(Air* handle);

static void clear_in_events(Air* handle);

static void micro_step(Air* handle);





void air_init(Air* handle)
{
	sc_integer i;
	
	for (i = 0; i < AIR_MAX_ORTHOGONAL_STATES; ++i)
	{
		handle->stateConfVector[i] = Air_last_state;
	}
	
				
	clear_in_events(handle);
	swap_in_events(handle);
	
	sc_observable_init(&handle->iface.opened);
	sc_observable_init(&handle->iface.closed);
	sc_observable_init(&handle->iface.failed_open);
	sc_observable_init(&handle->iface.failed_closed);
	
	/* Default init sequence for statechart air */
	handle->internal.PWM = 0;
	handle->internal.RAD = bool_false;
	
	handle->isExecuting = bool_false;
}

void air_run_cycle(Air* handle)
{
	/* Performs a 'run to completion' step. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	swap_in_events(handle);
	micro_step(handle);
	handle->isExecuting = bool_false;
}

void air_enter(Air* handle)
{
	/* Activates the state machine. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	/* Default enter sequence for statechart air */
	enseq_main_region_default(handle);
	handle->isExecuting = bool_false;
}

void air_exit(Air* handle)
{
	/* Deactivates the state machine. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	/* Default exit sequence for statechart air */
	exseq_main_region(handle);
	handle->isExecuting = bool_false;
}


sc_boolean air_is_active(const Air* handle)
{
	sc_boolean result = bool_false;
	sc_integer i;
	
	for(i = 0; i < AIR_MAX_ORTHOGONAL_STATES; i++)
	{
		result = result || handle->stateConfVector[i] != Air_last_state;
	}
	
	return result;
}

/* 
 * Always returns 'false' since this state machine can never become final.
 */
sc_boolean air_is_final(const Air* handle)
{
	SC_UNUSED(handle);
	return bool_false;
}

void air_raise_time_event(Air* handle, sc_eventid evid)
{
	if ( ((sc_intptr_t)evid) >= ((sc_intptr_t)&(handle->timeEvents))
		&&  ((sc_intptr_t)evid) < ((sc_intptr_t)&(handle->timeEvents)) + (unsigned)sizeof(AirTimeEvents))
		{
		*(sc_boolean*)evid = bool_true;
	}
}

sc_boolean air_is_state_active(const Air* handle, AirStates state)
{
	sc_boolean result = bool_false;
	switch (state)
	{
		case Air_main_region_Open :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AIR_MAIN_REGION_OPEN] == Air_main_region_Open
			);
			break;
		case Air_main_region_DoClose :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AIR_MAIN_REGION_DOCLOSE] == Air_main_region_DoClose
			);
			break;
		case Air_main_region_DoOpen :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AIR_MAIN_REGION_DOOPEN] == Air_main_region_DoOpen
			);
			break;
		case Air_main_region_Welded :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AIR_MAIN_REGION_WELDED] == Air_main_region_Welded
			);
			break;
		case Air_main_region_Closed :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AIR_MAIN_REGION_CLOSED] >= Air_main_region_Closed
				&& handle->stateConfVector[SCVI_AIR_MAIN_REGION_CLOSED] <= Air_main_region_Closed_PWMController_PowerSave);
			break;
		case Air_main_region_Closed_PWMController_PullIn :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AIR_MAIN_REGION_CLOSED_PWMCONTROLLER_PULLIN] == Air_main_region_Closed_PWMController_PullIn
			);
			break;
		case Air_main_region_Closed_PWMController_PowerSave :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AIR_MAIN_REGION_CLOSED_PWMCONTROLLER_POWERSAVE] == Air_main_region_Closed_PWMController_PowerSave
			);
			break;
		case Air_main_region_CloseFailed :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AIR_MAIN_REGION_CLOSEFAILED] == Air_main_region_CloseFailed
			);
			break;
		default:
			result = bool_false;
			break;
	}
	return result;
}

static void swap_in_events(Air* handle)
{
	handle->current.iface.OpenAction_raised = handle->iface.OpenAction_raised;
	handle->iface.OpenAction_raised = bool_false;
	handle->current.iface.CloseAction_raised = handle->iface.CloseAction_raised;
	handle->iface.CloseAction_raised = bool_false;
	handle->current.timeEvents.air_main_region_DoClose_time_event_0_raised = handle->timeEvents.air_main_region_DoClose_tev0_raised;
	handle->timeEvents.air_main_region_DoClose_tev0_raised = bool_false;
	handle->current.timeEvents.air_main_region_DoOpen_time_event_0_raised = handle->timeEvents.air_main_region_DoOpen_tev0_raised;
	handle->timeEvents.air_main_region_DoOpen_tev0_raised = bool_false;
	handle->current.timeEvents.air_main_region_Closed_PWMController_PullIn_time_event_0_raised = handle->timeEvents.air_main_region_Closed_PWMController_PullIn_tev0_raised;
	handle->timeEvents.air_main_region_Closed_PWMController_PullIn_tev0_raised = bool_false;
}

static void clear_in_events(Air* handle)
{
	handle->iface.OpenAction_raised = bool_false;
	handle->iface.CloseAction_raised = bool_false;
	handle->timeEvents.air_main_region_DoClose_tev0_raised = bool_false;
	handle->timeEvents.air_main_region_DoOpen_tev0_raised = bool_false;
	handle->timeEvents.air_main_region_Closed_PWMController_PullIn_tev0_raised = bool_false;
}

static void micro_step(Air* handle)
{
	switch(handle->stateConfVector[ 0 ])
	{
		case Air_main_region_Open :
		{
			main_region_Open_react(handle, -1);
			break;
		}
		case Air_main_region_DoClose :
		{
			main_region_DoClose_react(handle, -1);
			break;
		}
		case Air_main_region_DoOpen :
		{
			main_region_DoOpen_react(handle, -1);
			break;
		}
		case Air_main_region_Welded :
		{
			main_region_Welded_react(handle, -1);
			break;
		}
		case Air_main_region_Closed_PWMController_PullIn :
		{
			main_region_Closed_PWMController_PullIn_react(handle, -1);
			break;
		}
		case Air_main_region_Closed_PWMController_PowerSave :
		{
			main_region_Closed_PWMController_PowerSave_react(handle, -1);
			break;
		}
		case Air_main_region_CloseFailed :
		{
			main_region_CloseFailed_react(handle, -1);
			break;
		}
		default: break;
	}
}


void air_raise_openAction(Air* handle)
{
	handle->iface.OpenAction_raised = bool_true;
}

void air_raise_closeAction(Air* handle)
{
	handle->iface.CloseAction_raised = bool_true;
}


sc_observable* air_get_opened(Air* handle)
{
	return &handle->iface.opened;
}
sc_observable* air_get_closed(Air* handle)
{
	return &handle->iface.closed;
}
sc_observable* air_get_failed_open(Air* handle)
{
	return &handle->iface.failed_open;
}
sc_observable* air_get_failed_closed(Air* handle)
{
	return &handle->iface.failed_closed;
}


/* implementations of all internal functions */

/* Entry action for state 'Open'. */
static void enact_main_region_Open(Air* handle)
{
	/* Entry action for state 'Open'. */
	sc_observable_next(&handle->iface.opened)
	;
}

/* Entry action for state 'DoClose'. */
static void enact_main_region_DoClose(Air* handle)
{
	/* Entry action for state 'DoClose'. */
	air_set_timer(handle, (sc_eventid) &(handle->timeEvents.air_main_region_DoClose_tev0_raised) , (1 * 1000), bool_false);
	handle->internal.PWM = 100;
}

/* Entry action for state 'DoOpen'. */
static void enact_main_region_DoOpen(Air* handle)
{
	/* Entry action for state 'DoOpen'. */
	air_set_timer(handle, (sc_eventid) &(handle->timeEvents.air_main_region_DoOpen_tev0_raised) , (10 * 1000), bool_false);
	handle->internal.PWM = 0;
}

/* Entry action for state 'Welded'. */
static void enact_main_region_Welded(Air* handle)
{
	/* Entry action for state 'Welded'. */
	sc_observable_next(&handle->iface.failed_closed)
	;
}

/* Entry action for state 'Closed'. */
static void enact_main_region_Closed(Air* handle)
{
	/* Entry action for state 'Closed'. */
	sc_observable_next(&handle->iface.closed)
	;
}

/* Entry action for state 'PullIn'. */
static void enact_main_region_Closed_PWMController_PullIn(Air* handle)
{
	/* Entry action for state 'PullIn'. */
	air_set_timer(handle, (sc_eventid) &(handle->timeEvents.air_main_region_Closed_PWMController_PullIn_tev0_raised) , (2 * 1000), bool_false);
	handle->internal.PWM = 100;
}

/* Entry action for state 'PowerSave'. */
static void enact_main_region_Closed_PWMController_PowerSave(Air* handle)
{
	/* Entry action for state 'PowerSave'. */
	handle->internal.PWM = 20;
}

/* Entry action for state 'CloseFailed'. */
static void enact_main_region_CloseFailed(Air* handle)
{
	/* Entry action for state 'CloseFailed'. */
	sc_observable_next(&handle->iface.failed_open)
	;
	handle->internal.PWM = 0;
}

/* Exit action for state 'DoClose'. */
static void exact_main_region_DoClose(Air* handle)
{
	/* Exit action for state 'DoClose'. */
	air_unset_timer(handle, (sc_eventid) &(handle->timeEvents.air_main_region_DoClose_tev0_raised) );		
}

/* Exit action for state 'DoOpen'. */
static void exact_main_region_DoOpen(Air* handle)
{
	/* Exit action for state 'DoOpen'. */
	air_unset_timer(handle, (sc_eventid) &(handle->timeEvents.air_main_region_DoOpen_tev0_raised) );		
}

/* Exit action for state 'PullIn'. */
static void exact_main_region_Closed_PWMController_PullIn(Air* handle)
{
	/* Exit action for state 'PullIn'. */
	air_unset_timer(handle, (sc_eventid) &(handle->timeEvents.air_main_region_Closed_PWMController_PullIn_tev0_raised) );		
}

/* 'default' enter sequence for state Open */
static void enseq_main_region_Open_default(Air* handle)
{
	/* 'default' enter sequence for state Open */
	enact_main_region_Open(handle);
	handle->stateConfVector[0] = Air_main_region_Open;
}

/* 'default' enter sequence for state DoClose */
static void enseq_main_region_DoClose_default(Air* handle)
{
	/* 'default' enter sequence for state DoClose */
	enact_main_region_DoClose(handle);
	handle->stateConfVector[0] = Air_main_region_DoClose;
}

/* 'default' enter sequence for state DoOpen */
static void enseq_main_region_DoOpen_default(Air* handle)
{
	/* 'default' enter sequence for state DoOpen */
	enact_main_region_DoOpen(handle);
	handle->stateConfVector[0] = Air_main_region_DoOpen;
}

/* 'default' enter sequence for state Welded */
static void enseq_main_region_Welded_default(Air* handle)
{
	/* 'default' enter sequence for state Welded */
	enact_main_region_Welded(handle);
	handle->stateConfVector[0] = Air_main_region_Welded;
}

/* 'default' enter sequence for state Closed */
static void enseq_main_region_Closed_default(Air* handle)
{
	/* 'default' enter sequence for state Closed */
	enact_main_region_Closed(handle);
	enseq_main_region_Closed_PWMController_default(handle);
}

/* 'default' enter sequence for state PullIn */
static void enseq_main_region_Closed_PWMController_PullIn_default(Air* handle)
{
	/* 'default' enter sequence for state PullIn */
	enact_main_region_Closed_PWMController_PullIn(handle);
	handle->stateConfVector[0] = Air_main_region_Closed_PWMController_PullIn;
}

/* 'default' enter sequence for state PowerSave */
static void enseq_main_region_Closed_PWMController_PowerSave_default(Air* handle)
{
	/* 'default' enter sequence for state PowerSave */
	enact_main_region_Closed_PWMController_PowerSave(handle);
	handle->stateConfVector[0] = Air_main_region_Closed_PWMController_PowerSave;
}

/* 'default' enter sequence for state CloseFailed */
static void enseq_main_region_CloseFailed_default(Air* handle)
{
	/* 'default' enter sequence for state CloseFailed */
	enact_main_region_CloseFailed(handle);
	handle->stateConfVector[0] = Air_main_region_CloseFailed;
}

/* 'default' enter sequence for region main region */
static void enseq_main_region_default(Air* handle)
{
	/* 'default' enter sequence for region main region */
	react_main_region__entry_Default(handle);
}

/* 'default' enter sequence for region PWMController */
static void enseq_main_region_Closed_PWMController_default(Air* handle)
{
	/* 'default' enter sequence for region PWMController */
	react_main_region_Closed_PWMController__entry_Default(handle);
}

/* Default exit sequence for state Open */
static void exseq_main_region_Open(Air* handle)
{
	/* Default exit sequence for state Open */
	handle->stateConfVector[0] = Air_last_state;
}

/* Default exit sequence for state DoClose */
static void exseq_main_region_DoClose(Air* handle)
{
	/* Default exit sequence for state DoClose */
	handle->stateConfVector[0] = Air_last_state;
	exact_main_region_DoClose(handle);
}

/* Default exit sequence for state DoOpen */
static void exseq_main_region_DoOpen(Air* handle)
{
	/* Default exit sequence for state DoOpen */
	handle->stateConfVector[0] = Air_last_state;
	exact_main_region_DoOpen(handle);
}

/* Default exit sequence for state Welded */
static void exseq_main_region_Welded(Air* handle)
{
	/* Default exit sequence for state Welded */
	handle->stateConfVector[0] = Air_last_state;
}

/* Default exit sequence for state Closed */
static void exseq_main_region_Closed(Air* handle)
{
	/* Default exit sequence for state Closed */
	exseq_main_region_Closed_PWMController(handle);
}

/* Default exit sequence for state PullIn */
static void exseq_main_region_Closed_PWMController_PullIn(Air* handle)
{
	/* Default exit sequence for state PullIn */
	handle->stateConfVector[0] = Air_last_state;
	exact_main_region_Closed_PWMController_PullIn(handle);
}

/* Default exit sequence for state PowerSave */
static void exseq_main_region_Closed_PWMController_PowerSave(Air* handle)
{
	/* Default exit sequence for state PowerSave */
	handle->stateConfVector[0] = Air_last_state;
}

/* Default exit sequence for state CloseFailed */
static void exseq_main_region_CloseFailed(Air* handle)
{
	/* Default exit sequence for state CloseFailed */
	handle->stateConfVector[0] = Air_last_state;
}

/* Default exit sequence for region main region */
static void exseq_main_region(Air* handle)
{
	/* Default exit sequence for region main region */
	/* Handle exit of all possible states (of air.main_region) at position 0... */
	switch(handle->stateConfVector[ 0 ])
	{
		case Air_main_region_Open :
		{
			exseq_main_region_Open(handle);
			break;
		}
		case Air_main_region_DoClose :
		{
			exseq_main_region_DoClose(handle);
			break;
		}
		case Air_main_region_DoOpen :
		{
			exseq_main_region_DoOpen(handle);
			break;
		}
		case Air_main_region_Welded :
		{
			exseq_main_region_Welded(handle);
			break;
		}
		case Air_main_region_Closed_PWMController_PullIn :
		{
			exseq_main_region_Closed_PWMController_PullIn(handle);
			break;
		}
		case Air_main_region_Closed_PWMController_PowerSave :
		{
			exseq_main_region_Closed_PWMController_PowerSave(handle);
			break;
		}
		case Air_main_region_CloseFailed :
		{
			exseq_main_region_CloseFailed(handle);
			break;
		}
		default: break;
	}
}

/* Default exit sequence for region PWMController */
static void exseq_main_region_Closed_PWMController(Air* handle)
{
	/* Default exit sequence for region PWMController */
	/* Handle exit of all possible states (of air.main_region.Closed.PWMController) at position 0... */
	switch(handle->stateConfVector[ 0 ])
	{
		case Air_main_region_Closed_PWMController_PullIn :
		{
			exseq_main_region_Closed_PWMController_PullIn(handle);
			break;
		}
		case Air_main_region_Closed_PWMController_PowerSave :
		{
			exseq_main_region_Closed_PWMController_PowerSave(handle);
			break;
		}
		default: break;
	}
}

/* Default react sequence for initial entry  */
static void react_main_region__entry_Default(Air* handle)
{
	/* Default react sequence for initial entry  */
	enseq_main_region_Open_default(handle);
}

/* Default react sequence for initial entry  */
static void react_main_region_Closed_PWMController__entry_Default(Air* handle)
{
	/* Default react sequence for initial entry  */
	enseq_main_region_Closed_PWMController_PullIn_default(handle);
}


static sc_integer react(Air* handle, const sc_integer transitioned_before)
{
	/* State machine reactions. */
	SC_UNUSED(handle);
	return transitioned_before;
}

static sc_integer main_region_Open_react(Air* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Open. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.iface.CloseAction_raised == bool_true)
		{ 
			exseq_main_region_Open(handle);
			enseq_main_region_DoClose_default(handle);
			react(handle, 0);
			transitioned_after = 0;
		}  else
		{
			if ((handle->internal.RAD) == (bool_true))
			{ 
				exseq_main_region_Open(handle);
				enseq_main_region_Welded_default(handle);
				react(handle, 0);
				transitioned_after = 0;
			} 
		}
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_DoClose_react(Air* handle, const sc_integer transitioned_before)
{
	/* The reactions of state DoClose. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.iface.OpenAction_raised == bool_true)
		{ 
			exseq_main_region_DoClose(handle);
			enseq_main_region_DoOpen_default(handle);
			react(handle, 0);
			transitioned_after = 0;
		}  else
		{
			if ((handle->internal.RAD) == (bool_true))
			{ 
				exseq_main_region_DoClose(handle);
				enseq_main_region_Closed_default(handle);
				react(handle, 0);
				transitioned_after = 0;
			}  else
			{
				if (((handle->current.timeEvents.air_main_region_DoClose_time_event_0_raised) == bool_true) && (((handle->internal.RAD) == (bool_false)) == bool_true))
				{ 
					exseq_main_region_DoClose(handle);
					enseq_main_region_CloseFailed_default(handle);
					react(handle, 0);
					transitioned_after = 0;
				} 
			}
		}
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_DoOpen_react(Air* handle, const sc_integer transitioned_before)
{
	/* The reactions of state DoOpen. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if ((handle->internal.RAD) == (bool_false))
		{ 
			exseq_main_region_DoOpen(handle);
			enseq_main_region_Open_default(handle);
			react(handle, 0);
			transitioned_after = 0;
		}  else
		{
			if (handle->current.timeEvents.air_main_region_DoOpen_time_event_0_raised == bool_true)
			{ 
				exseq_main_region_DoOpen(handle);
				enseq_main_region_Welded_default(handle);
				react(handle, 0);
				transitioned_after = 0;
			} 
		}
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_Welded_react(Air* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Welded. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_Closed_react(Air* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Closed. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.iface.OpenAction_raised == bool_true)
		{ 
			exseq_main_region_Closed(handle);
			enseq_main_region_DoOpen_default(handle);
			react(handle, 0);
			transitioned_after = 0;
		}  else
		{
			if ((handle->internal.RAD) == (bool_false))
			{ 
				exseq_main_region_Closed(handle);
				enseq_main_region_CloseFailed_default(handle);
				react(handle, 0);
				transitioned_after = 0;
			} 
		}
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_Closed_PWMController_PullIn_react(Air* handle, const sc_integer transitioned_before)
{
	/* The reactions of state PullIn. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.timeEvents.air_main_region_Closed_PWMController_PullIn_time_event_0_raised == bool_true)
		{ 
			exseq_main_region_Closed_PWMController_PullIn(handle);
			enseq_main_region_Closed_PWMController_PowerSave_default(handle);
			main_region_Closed_react(handle, 0);
			transitioned_after = 0;
		} 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = main_region_Closed_react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_Closed_PWMController_PowerSave_react(Air* handle, const sc_integer transitioned_before)
{
	/* The reactions of state PowerSave. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = main_region_Closed_react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_CloseFailed_react(Air* handle, const sc_integer transitioned_before)
{
	/* The reactions of state CloseFailed. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.iface.OpenAction_raised == bool_true)
		{ 
			exseq_main_region_CloseFailed(handle);
			enseq_main_region_Open_default(handle);
			react(handle, 0);
			transitioned_after = 0;
		} 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}




