/** Generated by YAKINDU Statechart Tools code generator. */


#include "..\src\sc_types.h"

#include "ams.h"
#include "ams_required.h"

/*! \file Implementation of the state machine 'ams'
*/

#ifndef SC_UNUSED
#define SC_UNUSED(P) (void)(P)
#endif

/* prototypes of all internal functions */
static void effect_main_region_HV_Active_active_states_Precharging_tr0(Ams* handle);
static void enact_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L(Ams* handle);
static void enact_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge(Ams* handle);
static void enact_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H(Ams* handle);
static void enact_main_region_Discharging_Discharge_sequence_Wait_for_current(Ams* handle);
static void enact_main_region_Discharging_Discharge_sequence_Discharge(Ams* handle);
static void enact_main_region_Setup(Ams* handle);
static void exact_main_region_Discharging_Discharge_sequence_Wait_for_current(Ams* handle);
static void enseq_main_region_Standby_default(Ams* handle);
static void enseq_main_region_Armed_default(Ams* handle);
static void enseq_main_region_HV_Active_default(Ams* handle);
static void enseq_main_region_HV_Active_active_states_Precharging_default(Ams* handle);
static void enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L_default(Ams* handle);
static void enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge_default(Ams* handle);
static void enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H_default(Ams* handle);
static void enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage_default(Ams* handle);
static void enseq_main_region_HV_Active_active_states_ready_to_drive_default(Ams* handle);
static void enseq_main_region_Discharging_default(Ams* handle);
static void enseq_main_region_Discharging_Discharge_sequence_Wait_for_current_default(Ams* handle);
static void enseq_main_region_Discharging_Discharge_sequence_Discharge_default(Ams* handle);
static void enseq_main_region_error_discharging_default(Ams* handle);
static void enseq_main_region_Setup_default(Ams* handle);
static void enseq_main_region_default(Ams* handle);
static void enseq_main_region_HV_Active_active_states_default(Ams* handle);
static void enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_default(Ams* handle);
static void enseq_main_region_Discharging_Discharge_sequence_default(Ams* handle);
static void exseq_main_region_Standby(Ams* handle);
static void exseq_main_region_Armed(Ams* handle);
static void exseq_main_region_HV_Active(Ams* handle);
static void exseq_main_region_HV_Active_active_states_Precharging(Ams* handle);
static void exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L(Ams* handle);
static void exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge(Ams* handle);
static void exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H(Ams* handle);
static void exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage(Ams* handle);
static void exseq_main_region_HV_Active_active_states_ready_to_drive(Ams* handle);
static void exseq_main_region_Discharging(Ams* handle);
static void exseq_main_region_Discharging_Discharge_sequence_Wait_for_current(Ams* handle);
static void exseq_main_region_Discharging_Discharge_sequence_Discharge(Ams* handle);
static void exseq_main_region_error_discharging(Ams* handle);
static void exseq_main_region_Setup(Ams* handle);
static void exseq_main_region(Ams* handle);
static void exseq_main_region_HV_Active_active_states(Ams* handle);
static void exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence(Ams* handle);
static void exseq_main_region_Discharging_Discharge_sequence(Ams* handle);
static void react_main_region__entry_Default(Ams* handle);
static void react_main_region_HV_Active_active_states_Precharging_precharge_sequence__entry_Default(Ams* handle);
static void react_main_region_HV_Active_active_states__entry_Default(Ams* handle);
static void react_main_region_Discharging_Discharge_sequence__entry_Default(Ams* handle);
static void react_main_region_HV_Active_active_states_Precharging_precharge_sequence_precharge_done(Ams* handle);

/*! State machine reactions. */
static sc_integer react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state Standby. */
static sc_integer main_region_Standby_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state Armed. */
static sc_integer main_region_Armed_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state HV_Active. */
static sc_integer main_region_HV_Active_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state Precharging. */
static sc_integer main_region_HV_Active_active_states_Precharging_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state Close_L. */
static sc_integer main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state Close_Precharge. */
static sc_integer main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state Close_H. */
static sc_integer main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state Wait_voltage. */
static sc_integer main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state ready to drive. */
static sc_integer main_region_HV_Active_active_states_ready_to_drive_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state Discharging. */
static sc_integer main_region_Discharging_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state Wait for current. */
static sc_integer main_region_Discharging_Discharge_sequence_Wait_for_current_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state Discharge. */
static sc_integer main_region_Discharging_Discharge_sequence_Discharge_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state error discharging. */
static sc_integer main_region_error_discharging_react(Ams* handle, const sc_integer transitioned_before);

/*! The reactions of state Setup. */
static sc_integer main_region_Setup_react(Ams* handle, const sc_integer transitioned_before);


static void swap_in_events(Ams* handle);

static void clear_in_events(Ams* handle);

static void micro_step(Ams* handle);


static void on_air_l_failed_open(Ams* handle);
static void on_air_h_failed_open(Ams* handle);
static void on_precharge_failed_open(Ams* handle);
static void on_air_l_closed(Ams* handle);
static void on_precharge_closed(Ams* handle);
static void on_air_h_closed(Ams* handle);



void ams_init(Ams* handle)
{
	sc_integer i;
	
	for (i = 0; i < AMS_MAX_ORTHOGONAL_STATES; ++i)
	{
		handle->stateConfVector[i] = Ams_last_state;
	}
	
				
	clear_in_events(handle);
	swap_in_events(handle);
	
	sc_single_subscription_observer_init(&(handle->shadow.air_l_failed_open), handle, (sc_observer_next_fp)on_air_l_failed_open);
	sc_single_subscription_observer_init(&(handle->shadow.air_h_failed_open), handle, (sc_observer_next_fp)on_air_h_failed_open);
	sc_single_subscription_observer_init(&(handle->shadow.precharge_failed_open), handle, (sc_observer_next_fp)on_precharge_failed_open);
	sc_single_subscription_observer_init(&(handle->shadow.air_l_closed), handle, (sc_observer_next_fp)on_air_l_closed);
	sc_single_subscription_observer_init(&(handle->shadow.precharge_closed), handle, (sc_observer_next_fp)on_precharge_closed);
	sc_single_subscription_observer_init(&(handle->shadow.air_h_closed), handle, (sc_observer_next_fp)on_air_h_closed);
	
	/* Default init sequence for statechart ams */
	handle->iface.air_h = sc_null;
	handle->iface.air_l = sc_null;
	handle->iface.precharge = sc_null;
	handle->iface.TSMS = bool_false;
	handle->iface.V_MC = 0.0;
	handle->iface.I_bat = 0.0;
	
	handle->isExecuting = bool_false;
}

void ams_run_cycle(Ams* handle)
{
	/* Performs a 'run to completion' step. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	swap_in_events(handle);
	micro_step(handle);
	handle->isExecuting = bool_false;
}

void ams_enter(Ams* handle)
{
	/* Activates the state machine. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	/* Default enter sequence for statechart ams */
	enseq_main_region_default(handle);
	handle->isExecuting = bool_false;
}

void ams_exit(Ams* handle)
{
	/* Deactivates the state machine. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	/* Default exit sequence for statechart ams */
	exseq_main_region(handle);
	handle->isExecuting = bool_false;
}


sc_boolean ams_is_active(const Ams* handle)
{
	sc_boolean result = bool_false;
	sc_integer i;
	
	for(i = 0; i < AMS_MAX_ORTHOGONAL_STATES; i++)
	{
		result = result || handle->stateConfVector[i] != Ams_last_state;
	}
	
	return result;
}

/* 
 * Always returns 'false' since this state machine can never become final.
 */
sc_boolean ams_is_final(const Ams* handle)
{
	SC_UNUSED(handle);
	return bool_false;
}

void ams_raise_time_event(Ams* handle, sc_eventid evid)
{
	if ( ((sc_intptr_t)evid) >= ((sc_intptr_t)&(handle->timeEvents))
		&&  ((sc_intptr_t)evid) < ((sc_intptr_t)&(handle->timeEvents)) + (unsigned)sizeof(AmsTimeEvents))
		{
		*(sc_boolean*)evid = bool_true;
	}
}

sc_boolean ams_is_state_active(const Ams* handle, AmsStates state)
{
	sc_boolean result = bool_false;
	switch (state)
	{
		case Ams_main_region_Standby :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_STANDBY] == Ams_main_region_Standby
			);
			break;
		case Ams_main_region_Armed :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_ARMED] == Ams_main_region_Armed
			);
			break;
		case Ams_main_region_HV_Active :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_HV_ACTIVE] >= Ams_main_region_HV_Active
				&& handle->stateConfVector[SCVI_AMS_MAIN_REGION_HV_ACTIVE] <= Ams_main_region_HV_Active_active_states_ready_to_drive);
			break;
		case Ams_main_region_HV_Active_active_states_Precharging :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_PRECHARGING] >= Ams_main_region_HV_Active_active_states_Precharging
				&& handle->stateConfVector[SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_PRECHARGING] <= Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage);
			break;
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_PRECHARGING_PRECHARGE_SEQUENCE_CLOSE_L] == Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L
			);
			break;
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_PRECHARGING_PRECHARGE_SEQUENCE_CLOSE_PRECHARGE] == Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge
			);
			break;
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_PRECHARGING_PRECHARGE_SEQUENCE_CLOSE_H] == Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H
			);
			break;
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_PRECHARGING_PRECHARGE_SEQUENCE_WAIT_VOLTAGE] == Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage
			);
			break;
		case Ams_main_region_HV_Active_active_states_ready_to_drive :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_HV_ACTIVE_ACTIVE_STATES_READY_TO_DRIVE] == Ams_main_region_HV_Active_active_states_ready_to_drive
			);
			break;
		case Ams_main_region_Discharging :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_DISCHARGING] >= Ams_main_region_Discharging
				&& handle->stateConfVector[SCVI_AMS_MAIN_REGION_DISCHARGING] <= Ams_main_region_Discharging_Discharge_sequence_Discharge);
			break;
		case Ams_main_region_Discharging_Discharge_sequence_Wait_for_current :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_DISCHARGING_DISCHARGE_SEQUENCE_WAIT_FOR_CURRENT] == Ams_main_region_Discharging_Discharge_sequence_Wait_for_current
			);
			break;
		case Ams_main_region_Discharging_Discharge_sequence_Discharge :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_DISCHARGING_DISCHARGE_SEQUENCE_DISCHARGE] == Ams_main_region_Discharging_Discharge_sequence_Discharge
			);
			break;
		case Ams_main_region_error_discharging :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_ERROR_DISCHARGING] == Ams_main_region_error_discharging
			);
			break;
		case Ams_main_region_Setup :
			result = (sc_boolean) (handle->stateConfVector[SCVI_AMS_MAIN_REGION_SETUP] == Ams_main_region_Setup
			);
			break;
		default:
			result = bool_false;
			break;
	}
	return result;
}

static void swap_in_events(Ams* handle)
{
	handle->current.iface.Discharge_raised = handle->iface.Discharge_raised;
	handle->iface.Discharge_raised = bool_false;
	handle->current.iface.Charge_raised = handle->iface.Charge_raised;
	handle->iface.Charge_raised = bool_false;
	handle->current.timeEvents.ams_main_region_Discharging_Discharge_sequence_Wait_for_current_time_event_0_raised = handle->timeEvents.ams_main_region_Discharging_Discharge_sequence_Wait_for_current_tev0_raised;
	handle->timeEvents.ams_main_region_Discharging_Discharge_sequence_Wait_for_current_tev0_raised = bool_false;
	handle->current.shadow.air_l_failed_open_raised = handle->shadow.air_l_failed_open_raised;
	handle->shadow.air_l_failed_open_raised = bool_false;
	handle->current.shadow.air_h_failed_open_raised = handle->shadow.air_h_failed_open_raised;
	handle->shadow.air_h_failed_open_raised = bool_false;
	handle->current.shadow.precharge_failed_open_raised = handle->shadow.precharge_failed_open_raised;
	handle->shadow.precharge_failed_open_raised = bool_false;
	handle->current.shadow.air_l_closed_raised = handle->shadow.air_l_closed_raised;
	handle->shadow.air_l_closed_raised = bool_false;
	handle->current.shadow.precharge_closed_raised = handle->shadow.precharge_closed_raised;
	handle->shadow.precharge_closed_raised = bool_false;
	handle->current.shadow.air_h_closed_raised = handle->shadow.air_h_closed_raised;
	handle->shadow.air_h_closed_raised = bool_false;
}

static void clear_in_events(Ams* handle)
{
	handle->iface.Discharge_raised = bool_false;
	handle->iface.Charge_raised = bool_false;
	handle->shadow.air_l_failed_open_raised = bool_false;
	handle->shadow.air_h_failed_open_raised = bool_false;
	handle->shadow.precharge_failed_open_raised = bool_false;
	handle->shadow.air_l_closed_raised = bool_false;
	handle->shadow.precharge_closed_raised = bool_false;
	handle->shadow.air_h_closed_raised = bool_false;
	handle->timeEvents.ams_main_region_Discharging_Discharge_sequence_Wait_for_current_tev0_raised = bool_false;
}

static void micro_step(Ams* handle)
{
	switch(handle->stateConfVector[ 0 ])
	{
		case Ams_main_region_Standby :
		{
			main_region_Standby_react(handle, -1);
			break;
		}
		case Ams_main_region_Armed :
		{
			main_region_Armed_react(handle, -1);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L :
		{
			main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L_react(handle, -1);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge :
		{
			main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge_react(handle, -1);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H :
		{
			main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H_react(handle, -1);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage :
		{
			main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage_react(handle, -1);
			break;
		}
		case Ams_main_region_HV_Active_active_states_ready_to_drive :
		{
			main_region_HV_Active_active_states_ready_to_drive_react(handle, -1);
			break;
		}
		case Ams_main_region_Discharging_Discharge_sequence_Wait_for_current :
		{
			main_region_Discharging_Discharge_sequence_Wait_for_current_react(handle, -1);
			break;
		}
		case Ams_main_region_Discharging_Discharge_sequence_Discharge :
		{
			main_region_Discharging_Discharge_sequence_Discharge_react(handle, -1);
			break;
		}
		case Ams_main_region_error_discharging :
		{
			main_region_error_discharging_react(handle, -1);
			break;
		}
		case Ams_main_region_Setup :
		{
			main_region_Setup_react(handle, -1);
			break;
		}
		default: break;
	}
}


void ams_raise_discharge(Ams* handle)
{
	handle->iface.Discharge_raised = bool_true;
}

void ams_raise_charge(Ams* handle)
{
	handle->iface.Charge_raised = bool_true;
}



Air* ams_get_air_h(const Ams* handle)
{
	return handle->iface.air_h;
}
void ams_set_air_h(Ams* handle, Air* value)
{
	if(handle->iface.air_h != sc_null)
	{
		sc_single_subscription_observer_unsubscribe(&(handle->shadow.air_h_closed), air_get_closed(handle->iface.air_h));
		sc_single_subscription_observer_unsubscribe(&(handle->shadow.air_h_failed_open), air_get_failed_open(handle->iface.air_h));
	}
	handle->iface.air_h = value;
	if(handle->iface.air_h != sc_null)
	{
		sc_single_subscription_observer_subscribe(&(handle->shadow.air_h_closed), air_get_closed(handle->iface.air_h));
		sc_single_subscription_observer_subscribe(&(handle->shadow.air_h_failed_open), air_get_failed_open(handle->iface.air_h));
	}
}
Air* ams_get_air_l(const Ams* handle)
{
	return handle->iface.air_l;
}
void ams_set_air_l(Ams* handle, Air* value)
{
	if(handle->iface.air_l != sc_null)
	{
		sc_single_subscription_observer_unsubscribe(&(handle->shadow.air_l_closed), air_get_closed(handle->iface.air_l));
		sc_single_subscription_observer_unsubscribe(&(handle->shadow.air_l_failed_open), air_get_failed_open(handle->iface.air_l));
	}
	handle->iface.air_l = value;
	if(handle->iface.air_l != sc_null)
	{
		sc_single_subscription_observer_subscribe(&(handle->shadow.air_l_closed), air_get_closed(handle->iface.air_l));
		sc_single_subscription_observer_subscribe(&(handle->shadow.air_l_failed_open), air_get_failed_open(handle->iface.air_l));
	}
}
Air* ams_get_precharge(const Ams* handle)
{
	return handle->iface.precharge;
}
void ams_set_precharge(Ams* handle, Air* value)
{
	if(handle->iface.precharge != sc_null)
	{
		sc_single_subscription_observer_unsubscribe(&(handle->shadow.precharge_closed), air_get_closed(handle->iface.precharge));
		sc_single_subscription_observer_unsubscribe(&(handle->shadow.precharge_failed_open), air_get_failed_open(handle->iface.precharge));
	}
	handle->iface.precharge = value;
	if(handle->iface.precharge != sc_null)
	{
		sc_single_subscription_observer_subscribe(&(handle->shadow.precharge_closed), air_get_closed(handle->iface.precharge));
		sc_single_subscription_observer_subscribe(&(handle->shadow.precharge_failed_open), air_get_failed_open(handle->iface.precharge));
	}
}
sc_boolean ams_get_tSMS(const Ams* handle)
{
	return handle->iface.TSMS;
}
void ams_set_tSMS(Ams* handle, sc_boolean value)
{
	handle->iface.TSMS = value;
}
float ams_get_v_MC(const Ams* handle)
{
	return handle->iface.V_MC;
}
void ams_set_v_MC(Ams* handle, float value)
{
	handle->iface.V_MC = value;
}
float ams_get_i_bat(const Ams* handle)
{
	return handle->iface.I_bat;
}
void ams_set_i_bat(Ams* handle, float value)
{
	handle->iface.I_bat = value;
}

/* implementations of all internal functions */

static void effect_main_region_HV_Active_active_states_Precharging_tr0(Ams* handle)
{
	exseq_main_region_HV_Active_active_states_Precharging(handle);
	enseq_main_region_HV_Active_active_states_ready_to_drive_default(handle);
	main_region_HV_Active_react(handle, 0);
}

/* Entry action for state 'Close_L'. */
static void enact_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L(Ams* handle)
{
	/* Entry action for state 'Close_L'. */
	air_raise_closeAction(handle->iface.air_l);
}

/* Entry action for state 'Close_Precharge'. */
static void enact_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge(Ams* handle)
{
	/* Entry action for state 'Close_Precharge'. */
	air_raise_closeAction(handle->iface.precharge);
}

/* Entry action for state 'Close_H'. */
static void enact_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H(Ams* handle)
{
	/* Entry action for state 'Close_H'. */
	air_raise_closeAction(handle->iface.air_h);
}

/* Entry action for state 'Wait for current'. */
static void enact_main_region_Discharging_Discharge_sequence_Wait_for_current(Ams* handle)
{
	/* Entry action for state 'Wait for current'. */
	ams_set_timer(handle, (sc_eventid) &(handle->timeEvents.ams_main_region_Discharging_Discharge_sequence_Wait_for_current_tev0_raised) , 50, bool_false);
}

/* Entry action for state 'Discharge'. */
static void enact_main_region_Discharging_Discharge_sequence_Discharge(Ams* handle)
{
	/* Entry action for state 'Discharge'. */
	air_raise_openAction(handle->iface.air_l);
	air_raise_openAction(handle->iface.air_h);
	air_raise_openAction(handle->iface.precharge);
}

/* Entry action for state 'Setup'. */
static void enact_main_region_Setup(Ams* handle)
{
	/* Entry action for state 'Setup'. */
	air_enter(handle->iface.air_h);
	air_enter(handle->iface.air_l);
	air_enter(handle->iface.precharge);
}

/* Exit action for state 'Wait for current'. */
static void exact_main_region_Discharging_Discharge_sequence_Wait_for_current(Ams* handle)
{
	/* Exit action for state 'Wait for current'. */
	ams_unset_timer(handle, (sc_eventid) &(handle->timeEvents.ams_main_region_Discharging_Discharge_sequence_Wait_for_current_tev0_raised) );		
}

/* 'default' enter sequence for state Standby */
static void enseq_main_region_Standby_default(Ams* handle)
{
	/* 'default' enter sequence for state Standby */
	handle->stateConfVector[0] = Ams_main_region_Standby;
}

/* 'default' enter sequence for state Armed */
static void enseq_main_region_Armed_default(Ams* handle)
{
	/* 'default' enter sequence for state Armed */
	handle->stateConfVector[0] = Ams_main_region_Armed;
}

/* 'default' enter sequence for state HV_Active */
static void enseq_main_region_HV_Active_default(Ams* handle)
{
	/* 'default' enter sequence for state HV_Active */
	enseq_main_region_HV_Active_active_states_default(handle);
}

/* 'default' enter sequence for state Precharging */
static void enseq_main_region_HV_Active_active_states_Precharging_default(Ams* handle)
{
	/* 'default' enter sequence for state Precharging */
	enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_default(handle);
}

/* 'default' enter sequence for state Close_L */
static void enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L_default(Ams* handle)
{
	/* 'default' enter sequence for state Close_L */
	enact_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L(handle);
	handle->stateConfVector[0] = Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L;
}

/* 'default' enter sequence for state Close_Precharge */
static void enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge_default(Ams* handle)
{
	/* 'default' enter sequence for state Close_Precharge */
	enact_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge(handle);
	handle->stateConfVector[0] = Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge;
}

/* 'default' enter sequence for state Close_H */
static void enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H_default(Ams* handle)
{
	/* 'default' enter sequence for state Close_H */
	enact_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H(handle);
	handle->stateConfVector[0] = Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H;
}

/* 'default' enter sequence for state Wait_voltage */
static void enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage_default(Ams* handle)
{
	/* 'default' enter sequence for state Wait_voltage */
	handle->stateConfVector[0] = Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage;
}

/* 'default' enter sequence for state ready to drive */
static void enseq_main_region_HV_Active_active_states_ready_to_drive_default(Ams* handle)
{
	/* 'default' enter sequence for state ready to drive */
	handle->stateConfVector[0] = Ams_main_region_HV_Active_active_states_ready_to_drive;
}

/* 'default' enter sequence for state Discharging */
static void enseq_main_region_Discharging_default(Ams* handle)
{
	/* 'default' enter sequence for state Discharging */
	enseq_main_region_Discharging_Discharge_sequence_default(handle);
}

/* 'default' enter sequence for state Wait for current */
static void enseq_main_region_Discharging_Discharge_sequence_Wait_for_current_default(Ams* handle)
{
	/* 'default' enter sequence for state Wait for current */
	enact_main_region_Discharging_Discharge_sequence_Wait_for_current(handle);
	handle->stateConfVector[0] = Ams_main_region_Discharging_Discharge_sequence_Wait_for_current;
}

/* 'default' enter sequence for state Discharge */
static void enseq_main_region_Discharging_Discharge_sequence_Discharge_default(Ams* handle)
{
	/* 'default' enter sequence for state Discharge */
	enact_main_region_Discharging_Discharge_sequence_Discharge(handle);
	handle->stateConfVector[0] = Ams_main_region_Discharging_Discharge_sequence_Discharge;
}

/* 'default' enter sequence for state error discharging */
static void enseq_main_region_error_discharging_default(Ams* handle)
{
	/* 'default' enter sequence for state error discharging */
	handle->stateConfVector[0] = Ams_main_region_error_discharging;
}

/* 'default' enter sequence for state Setup */
static void enseq_main_region_Setup_default(Ams* handle)
{
	/* 'default' enter sequence for state Setup */
	enact_main_region_Setup(handle);
	handle->stateConfVector[0] = Ams_main_region_Setup;
}

/* 'default' enter sequence for region main region */
static void enseq_main_region_default(Ams* handle)
{
	/* 'default' enter sequence for region main region */
	react_main_region__entry_Default(handle);
}

/* 'default' enter sequence for region active states */
static void enseq_main_region_HV_Active_active_states_default(Ams* handle)
{
	/* 'default' enter sequence for region active states */
	react_main_region_HV_Active_active_states__entry_Default(handle);
}

/* 'default' enter sequence for region precharge sequence */
static void enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_default(Ams* handle)
{
	/* 'default' enter sequence for region precharge sequence */
	react_main_region_HV_Active_active_states_Precharging_precharge_sequence__entry_Default(handle);
}

/* 'default' enter sequence for region Discharge sequence */
static void enseq_main_region_Discharging_Discharge_sequence_default(Ams* handle)
{
	/* 'default' enter sequence for region Discharge sequence */
	react_main_region_Discharging_Discharge_sequence__entry_Default(handle);
}

/* Default exit sequence for state Standby */
static void exseq_main_region_Standby(Ams* handle)
{
	/* Default exit sequence for state Standby */
	handle->stateConfVector[0] = Ams_last_state;
}

/* Default exit sequence for state Armed */
static void exseq_main_region_Armed(Ams* handle)
{
	/* Default exit sequence for state Armed */
	handle->stateConfVector[0] = Ams_last_state;
}

/* Default exit sequence for state HV_Active */
static void exseq_main_region_HV_Active(Ams* handle)
{
	/* Default exit sequence for state HV_Active */
	exseq_main_region_HV_Active_active_states(handle);
}

/* Default exit sequence for state Precharging */
static void exseq_main_region_HV_Active_active_states_Precharging(Ams* handle)
{
	/* Default exit sequence for state Precharging */
	exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence(handle);
}

/* Default exit sequence for state Close_L */
static void exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L(Ams* handle)
{
	/* Default exit sequence for state Close_L */
	handle->stateConfVector[0] = Ams_last_state;
}

/* Default exit sequence for state Close_Precharge */
static void exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge(Ams* handle)
{
	/* Default exit sequence for state Close_Precharge */
	handle->stateConfVector[0] = Ams_last_state;
}

/* Default exit sequence for state Close_H */
static void exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H(Ams* handle)
{
	/* Default exit sequence for state Close_H */
	handle->stateConfVector[0] = Ams_last_state;
}

/* Default exit sequence for state Wait_voltage */
static void exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage(Ams* handle)
{
	/* Default exit sequence for state Wait_voltage */
	handle->stateConfVector[0] = Ams_last_state;
}

/* Default exit sequence for state ready to drive */
static void exseq_main_region_HV_Active_active_states_ready_to_drive(Ams* handle)
{
	/* Default exit sequence for state ready to drive */
	handle->stateConfVector[0] = Ams_last_state;
}

/* Default exit sequence for state Discharging */
static void exseq_main_region_Discharging(Ams* handle)
{
	/* Default exit sequence for state Discharging */
	exseq_main_region_Discharging_Discharge_sequence(handle);
}

/* Default exit sequence for state Wait for current */
static void exseq_main_region_Discharging_Discharge_sequence_Wait_for_current(Ams* handle)
{
	/* Default exit sequence for state Wait for current */
	handle->stateConfVector[0] = Ams_last_state;
	exact_main_region_Discharging_Discharge_sequence_Wait_for_current(handle);
}

/* Default exit sequence for state Discharge */
static void exseq_main_region_Discharging_Discharge_sequence_Discharge(Ams* handle)
{
	/* Default exit sequence for state Discharge */
	handle->stateConfVector[0] = Ams_last_state;
}

/* Default exit sequence for state error discharging */
static void exseq_main_region_error_discharging(Ams* handle)
{
	/* Default exit sequence for state error discharging */
	handle->stateConfVector[0] = Ams_last_state;
}

/* Default exit sequence for state Setup */
static void exseq_main_region_Setup(Ams* handle)
{
	/* Default exit sequence for state Setup */
	handle->stateConfVector[0] = Ams_last_state;
}

/* Default exit sequence for region main region */
static void exseq_main_region(Ams* handle)
{
	/* Default exit sequence for region main region */
	/* Handle exit of all possible states (of ams.main_region) at position 0... */
	switch(handle->stateConfVector[ 0 ])
	{
		case Ams_main_region_Standby :
		{
			exseq_main_region_Standby(handle);
			break;
		}
		case Ams_main_region_Armed :
		{
			exseq_main_region_Armed(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_ready_to_drive :
		{
			exseq_main_region_HV_Active_active_states_ready_to_drive(handle);
			break;
		}
		case Ams_main_region_Discharging_Discharge_sequence_Wait_for_current :
		{
			exseq_main_region_Discharging_Discharge_sequence_Wait_for_current(handle);
			break;
		}
		case Ams_main_region_Discharging_Discharge_sequence_Discharge :
		{
			exseq_main_region_Discharging_Discharge_sequence_Discharge(handle);
			break;
		}
		case Ams_main_region_error_discharging :
		{
			exseq_main_region_error_discharging(handle);
			break;
		}
		case Ams_main_region_Setup :
		{
			exseq_main_region_Setup(handle);
			break;
		}
		default: break;
	}
}

/* Default exit sequence for region active states */
static void exseq_main_region_HV_Active_active_states(Ams* handle)
{
	/* Default exit sequence for region active states */
	/* Handle exit of all possible states (of ams.main_region.HV_Active.active_states) at position 0... */
	switch(handle->stateConfVector[ 0 ])
	{
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_ready_to_drive :
		{
			exseq_main_region_HV_Active_active_states_ready_to_drive(handle);
			break;
		}
		default: break;
	}
}

/* Default exit sequence for region precharge sequence */
static void exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence(Ams* handle)
{
	/* Default exit sequence for region precharge sequence */
	/* Handle exit of all possible states (of ams.main_region.HV_Active.active_states.Precharging.precharge_sequence) at position 0... */
	switch(handle->stateConfVector[ 0 ])
	{
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H(handle);
			break;
		}
		case Ams_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage :
		{
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage(handle);
			break;
		}
		default: break;
	}
}

/* Default exit sequence for region Discharge sequence */
static void exseq_main_region_Discharging_Discharge_sequence(Ams* handle)
{
	/* Default exit sequence for region Discharge sequence */
	/* Handle exit of all possible states (of ams.main_region.Discharging.Discharge_sequence) at position 0... */
	switch(handle->stateConfVector[ 0 ])
	{
		case Ams_main_region_Discharging_Discharge_sequence_Wait_for_current :
		{
			exseq_main_region_Discharging_Discharge_sequence_Wait_for_current(handle);
			break;
		}
		case Ams_main_region_Discharging_Discharge_sequence_Discharge :
		{
			exseq_main_region_Discharging_Discharge_sequence_Discharge(handle);
			break;
		}
		default: break;
	}
}

/* Default react sequence for initial entry  */
static void react_main_region__entry_Default(Ams* handle)
{
	/* Default react sequence for initial entry  */
	enseq_main_region_Setup_default(handle);
}

/* Default react sequence for initial entry  */
static void react_main_region_HV_Active_active_states_Precharging_precharge_sequence__entry_Default(Ams* handle)
{
	/* Default react sequence for initial entry  */
	enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L_default(handle);
}

/* Default react sequence for initial entry  */
static void react_main_region_HV_Active_active_states__entry_Default(Ams* handle)
{
	/* Default react sequence for initial entry  */
	enseq_main_region_HV_Active_active_states_Precharging_default(handle);
}

/* Default react sequence for initial entry  */
static void react_main_region_Discharging_Discharge_sequence__entry_Default(Ams* handle)
{
	/* Default react sequence for initial entry  */
	enseq_main_region_Discharging_Discharge_sequence_Wait_for_current_default(handle);
}

/* The reactions of exit precharge_done. */
static void react_main_region_HV_Active_active_states_Precharging_precharge_sequence_precharge_done(Ams* handle)
{
	/* The reactions of exit precharge_done. */
	effect_main_region_HV_Active_active_states_Precharging_tr0(handle);
}


static sc_integer react(Ams* handle, const sc_integer transitioned_before)
{
	/* State machine reactions. */
	air_run_cycle(handle->iface.air_l);
	air_run_cycle(handle->iface.air_h);
	air_run_cycle(handle->iface.precharge);
	return transitioned_before;
}

static sc_integer main_region_Standby_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Standby. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if ((handle->iface.TSMS) == (bool_true))
		{ 
			exseq_main_region_Standby(handle);
			enseq_main_region_Armed_default(handle);
			react(handle, 0);
			transitioned_after = 0;
		} 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_Armed_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Armed. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if ((handle->iface.TSMS) == (bool_false))
		{ 
			exseq_main_region_Armed(handle);
			enseq_main_region_Standby_default(handle);
			react(handle, 0);
			transitioned_after = 0;
		}  else
		{
			if (handle->current.iface.Charge_raised == bool_true)
			{ 
				exseq_main_region_Armed(handle);
				enseq_main_region_HV_Active_default(handle);
				react(handle, 0);
				transitioned_after = 0;
			} 
		}
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_HV_Active_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state HV_Active. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.iface.Discharge_raised == bool_true)
		{ 
			exseq_main_region_HV_Active(handle);
			enseq_main_region_Discharging_default(handle);
			react(handle, 0);
			transitioned_after = 0;
		}  else
		{
			if ((handle->current.shadow.air_l_failed_open_raised == bool_true) || ((handle->current.shadow.air_h_failed_open_raised == bool_true) || (handle->current.shadow.precharge_failed_open_raised == bool_true)))
			{ 
				exseq_main_region_HV_Active(handle);
				enseq_main_region_error_discharging_default(handle);
				react(handle, 0);
				transitioned_after = 0;
			} 
		}
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_HV_Active_active_states_Precharging_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Precharging. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = main_region_HV_Active_react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Close_L. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.shadow.air_l_closed_raised == bool_true)
		{ 
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_L(handle);
			enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge_default(handle);
			main_region_HV_Active_active_states_Precharging_react(handle, 0);
			transitioned_after = 0;
		} 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = main_region_HV_Active_active_states_Precharging_react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Close_Precharge. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.shadow.precharge_closed_raised == bool_true)
		{ 
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_Precharge(handle);
			enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage_default(handle);
			main_region_HV_Active_active_states_Precharging_react(handle, 0);
			transitioned_after = 0;
		} 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = main_region_HV_Active_active_states_Precharging_react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Close_H. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.shadow.air_h_closed_raised == bool_true)
		{ 
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H(handle);
			react_main_region_HV_Active_active_states_Precharging_precharge_sequence_precharge_done(handle);
			transitioned_after = 0;
		} 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = main_region_HV_Active_active_states_Precharging_react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Wait_voltage. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if ((handle->iface.V_MC) > (540))
		{ 
			exseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Wait_voltage(handle);
			enseq_main_region_HV_Active_active_states_Precharging_precharge_sequence_Close_H_default(handle);
			main_region_HV_Active_active_states_Precharging_react(handle, 0);
			transitioned_after = 0;
		} 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = main_region_HV_Active_active_states_Precharging_react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_HV_Active_active_states_ready_to_drive_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state ready to drive. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = main_region_HV_Active_react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_Discharging_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Discharging. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if ((handle->iface.V_MC) < (60))
		{ 
			exseq_main_region_Discharging(handle);
			enseq_main_region_Standby_default(handle);
			react(handle, 0);
			transitioned_after = 0;
		} 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_Discharging_Discharge_sequence_Wait_for_current_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Wait for current. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if ((handle->iface.I_bat) < (1))
		{ 
			exseq_main_region_Discharging_Discharge_sequence_Wait_for_current(handle);
			enseq_main_region_Discharging_Discharge_sequence_Discharge_default(handle);
			main_region_Discharging_react(handle, 0);
			transitioned_after = 0;
		}  else
		{
			if (handle->current.timeEvents.ams_main_region_Discharging_Discharge_sequence_Wait_for_current_time_event_0_raised == bool_true)
			{ 
				exseq_main_region_Discharging_Discharge_sequence_Wait_for_current(handle);
				enseq_main_region_Discharging_Discharge_sequence_Discharge_default(handle);
				main_region_Discharging_react(handle, 0);
				transitioned_after = 0;
			} 
		}
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = main_region_Discharging_react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_Discharging_Discharge_sequence_Discharge_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Discharge. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = main_region_Discharging_react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_error_discharging_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state error discharging. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.iface.Discharge_raised == bool_true)
		{ 
			exseq_main_region_error_discharging(handle);
			enseq_main_region_Discharging_default(handle);
			react(handle, 0);
			transitioned_after = 0;
		} 
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}

static sc_integer main_region_Setup_react(Ams* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Setup. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		exseq_main_region_Setup(handle);
		enseq_main_region_Standby_default(handle);
		react(handle, 0);
		transitioned_after = 0;
	} /* If no transition was taken then execute local reactions */
	if ((transitioned_after) == (transitioned_before))
	{ 
		transitioned_after = react(handle, transitioned_before);
	} return transitioned_after;
}


static void on_air_l_failed_open(Ams* handle)
{
	handle->shadow.air_l_failed_open_raised = bool_true;
}
static void on_air_h_failed_open(Ams* handle)
{
	handle->shadow.air_h_failed_open_raised = bool_true;
}
static void on_precharge_failed_open(Ams* handle)
{
	handle->shadow.precharge_failed_open_raised = bool_true;
}
static void on_air_l_closed(Ams* handle)
{
	handle->shadow.air_l_closed_raised = bool_true;
}
static void on_precharge_closed(Ams* handle)
{
	handle->shadow.precharge_closed_raised = bool_true;
}
static void on_air_h_closed(Ams* handle)
{
	handle->shadow.air_h_closed_raised = bool_true;
}


